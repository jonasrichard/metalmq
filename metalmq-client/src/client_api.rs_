use super::client::{self, RequestSink};
use super::{client_error, Channel, ClientChannel};
use anyhow::Result;
use metalmq_codec::frame;

/// Represents a connection to AMQP server. It is not a trait since async functions in a trait
/// are not yet supported.
#[derive(Debug)]
pub struct Client {
    sink: RequestSink,
    channels: Vec<Channel>,
}

/// Connect to an AMQP server.
///
/// This is async code and wait for the [`metalmq_codec::frame::ConnectionTuneOkArgs`] message.
///
/// ```no_run
/// async fn connect() -> anyhow::Result<()> {
///     let conn = metalmq_client::connect("localhost:5672", "guest", "guest").await?;
///     Ok(())
/// }
/// ```
pub async fn connect(url: &str, username: &str, password: &str) -> Result<Client> {
    let sink = client::create_connection(url.to_string()).await?;

    client::sync_call(&sink, frame::AMQPFrame::Header).await?;

    let mut caps = frame::FieldTable::new();

    caps.insert(
        "authentication_failure_close".to_string(),
        frame::AMQPFieldValue::Bool(true),
    );

    //caps.insert("basic.nack".to_string(), AMQPFieldValue::Bool(true));
    //caps.insert("connection.blocked".to_string(), AMQPFieldValue::Bool(true));
    //caps.insert("consumer_cancel_notify".to_string(), AMQPFieldValue::Bool(true));
    //caps.insert("publisher_confirms".to_string(), AMQPFieldValue::Bool(true));

    if client::sync_call(&sink, frame::connection_start_ok(username, password, caps))
        .await
        .is_err()
    {
        return client_error!(
            None,
            503,
            "Server closed connection during authentication",
            frame::CONNECTION_START_OK
        );
    }

    client::call(&sink, frame::connection_tune_ok(0)).await?;

    Ok(Client { sink, channels: vec![] })
}

impl Client {
    /// Client "connects" to a virtual host. The virtual host may or may not exist,
    /// in case of an error we got a `ClientError` and the connection closes.
    ///
    /// ```no_run
    /// use metalmq_client::*;
    ///
    /// async fn vhost(c: &Client) {
    ///     if let Err(ce) = c.open("/invalid").await {
    ///         eprintln!("Virtual host does not exist");
    ///     }
    /// }
    /// ```
    pub async fn open(&self, virtual_host: &str) -> Result<()> {
        client::sync_call(&self.sink, frame::connection_open(0, virtual_host)).await
    }

    /// Close client connection by closing all its channels.
    pub async fn close(&self) -> Result<()> {
        client::sync_call(&self.sink, frame::connection_close(0, 200, "Normal close", 0, 0)).await
    }

    /// Opens a channel an gives back the channel handler.
    ///
    /// All the major operations can be done through the channel.
    ///
    /// ```no_run
    /// use metalmq_client::*;
    ///
    /// async fn publish(c: &mut Client) -> anyhow::Result<()> {
    ///     let ch = c.channel_open(3).await?;
    ///
    ///     ch.basic_publish("exchange-name", "", "Here is the payload".to_string()).await?;
    ///     ch.close().await?;
    ///
    ///     Ok(())
    /// }
    /// ```
    pub async fn channel_open(&mut self, channel: u16) -> Result<ClientChannel> {
        client::sync_call(&self.sink, frame::channel_open(channel)).await?;

        self.channels.push(channel);

        Ok(ClientChannel {
            channel,
            sink: self.sink.clone(),
        })
    }
}
